/*
 * labonchip.c
 *
 *  Created on: 8 gen 2021
 *      Author: Augusto Nascetti
 */

#include "../memory/memory.h"
#include "labonchip.h"

uint8_t currentExperimentID;
uint8_t experimentStatus[NUMBER_OF_EXPERIMENTS];
uint16_t plannedStartTime[NUMBER_OF_EXPERIMENTS]; //in seconds
struct Experiment labonchipExperiment_[NUMBER_OF_EXPERIMENTS];

uint8_t standardActions[MAX_NUMBER_OF_STEPS]={INITEXP,PUMPi, MEASURE,FINISH,FINISH,FINISH}  // STANDARDSTEPS = 4
uint16_t standardDurations[MAX_NUMBER_OF_STEPS]={20, 60, 600,20,0,0,0};

void checkExperiment(){
    uint32_t timeNow = phoebe_millis();
    //check if is time do do a next step or to start a new experiment

    // start new experiment?
    if (satelliteStatus_.experimentRunning == 0){
        //no experiment running
        //check if it's time for a new experiment
        //1) check the next experiment to do
        int i;
        uint8_t expFound=0;
        uint16_t nextStartTime=0xFFFF;
        for(i=0; i<NUMBER_OF_EXPERIMENTS;i++){
            if(experimentStatus[i]==TODO){
                if (plannedStartTime[i]<nextStartTime){
                    nextStartTime=plannedStartTime[i];
                    satelliteStatus_.currentExperimentIndex=i;
                    expFound=1;
                }
            }
        }
        if (expFound==0){
            //no more experiments to do
            return;
        }
        // time to start the new experiment?
        if (((uint32_t)plannedStartTime[satelliteStatus_.currentExperimentIndex]*1000UL) > timeNow){
            //try to start next experiment
            if (startExperiment(satelliteStatus_.currentExperimentIndex)==0){
                satelliteStatus_.experimentRunning = 1;
                satelliteStatus_.startTimeCurrentExpStep = timeNow;
                satelliteStatus_.currentExperimentStep = 0;  // step 0 is always the START
                // the change of step is done on time-basis
                // and it's handeld in the running-experiment part
                currentExperimentID=labonchipExperiment_[satelliteStatus_.currentExperimentIndex].experimentID;
                experimentStatus[satelliteStatus_.currentExperimentIndex]=RUNNING;
            } else {
                // report error
                satelliteStatus_.experimentRunning = 0;
                satelliteStatus_.currentExperimentStep = 0;
                experimentStatus[satelliteStatus_.currentExperimentIndex]=INITERROR;
            }
        }
        return;
    }

    // there is a running experiment
    // is it time for a new step?
    if(     (satelliteStatus_.startTimeCurrentExpStep
            + (uint32_t)labonchipExperiment_[satelliteStatus_.currentExperimentIndex].stepDuration[satelliteStatus_.currentExperimentStep] * 1000UL)
            > timeNow)
    {
        //No need to do any action on the experiment yet
        //update time elapsed in current step
        labonchipExperiment_[satelliteStatus_.currentExperimentIndex].elapsedTimeinStep=timeNow-satelliteStatus_.startTimeCurrentExpStep;

        // check if there are asynchronous events to handle
        // like wet sensor or other events


        return;
    }

    // ok, it's time for the next step
    // stop the previous action if needed
    // NOTE: the current step is still the 'old' one

    labonchipExperiment_[satelliteStatus_.currentExperimentIndex].stepStatus[satelliteStatus_.currentExperimentStep]=COMPLETED;
    //logEvent
    switch (labonchipExperiment_[satelliteStatus_.currentExperimentIndex].stepAction[satelliteStatus_.currentExperimentStep]){
    case INITEXP:
        //store telemetry before the next step
        //configure beacon, telemetry and memory
        break;
    case PUMP1: case PUMP2: case PUMP3: case PUMP4: case PUMP5: case PUMP6:
        switchPumpOFF(labonchipExperiment_[satelliteStatus_.currentExperimentIndex].stepAction[satelliteStatus_.currentExperimentStep]);
        break;
    case MEASURE:
        // restore radio operations, telemetry, memory, ecc.
        break;
    case INCUBATE:

        break;
    case FINISH:
        // switch off MARIE
        // restore Normal opMode
        labonchipExperiment_[satelliteStatus_.currentExperimentIndex].endUnixTime=timeNOW;
        satelliteStatus_.experimentRunning = 0;
        satelliteStatus_.currentExperimentStep = 0;
        return;

        break;
    default:
        break;
    }

    // ... and start the new step
    if (satelliteStatus_.currentExperimentStep   >= labonchipExperiment_[satelliteStatus_.currentExperimentIndex].numberOfSteps ){
        // sanity check
        // the experiment should be finished
        // handle the problem
        return;
    }
    satelliteStatus_.currentExperimentStep++;  // go to the next step
    satelliteStatus_.startTimeCurrentExpStep = timeNow;
    labonchipExperiment_[satelliteStatus_.currentExperimentIndex].elapsedTimeinStep=0UL;
    labonchipExperiment_[satelliteStatus_.currentExperimentIndex].stepStatus[satelliteStatus_.currentExperimentStep]=RUNNING;
    //logEvent
    switch (labonchipExperiment_[satelliteStatus_.currentExperimentIndex].stepAction[satelliteStatus_.currentExperimentStep]){
    case INITEXP:
        //
        break;
    case PUMP1: case PUMP2: case PUMP3: case PUMP4: case PUMP5: case PUMP6:
        switchPumpON(labonchipExperiment_[satelliteStatus_.currentExperimentIndex].stepAction[satelliteStatus_.currentExperimentStep]);
        break;
    case MEASURE:
        // reduce noise sources (radio),
        // power consumption (radio),
        // and coordinate other disturbances ( e.g. accesses to the memory for telemetry save)
        // disable memory erases
        break;
    case INCUBATE:
        break;
    case FINISH:
        // disable MARIE interrupt
        // finish saving data
        labonchipExperiment_[satelliteStatus_.currentExperimentIndex].endUnixTime=timeNow;
        labonchipExperiment_[satelliteStatus_.currentExperimentIndex].expEndAddress=satelliteMemory_.marieStartFreeAddress; // -1 page
        break;
    default:
        break;
    }

}

int startExperiment(uint8_t experimentIndex){ //alternatively use experimentID

    if(experimentIndex >= NUMBER_OF_EXPERIMENTS)
        return;
    satelliteStatus_.currentExperimentIndex=experimentIndex;
    //labonchipExperiment_[experimentIndex].currentStep=0; //check if it is needed
    //probably the satelliteStatus_.currentExperimentStep is enough and more efficient
    //because it requires less memory and only one experiment at time is executed
    //(indeed it can be useful if overlapped experiments were made)
    satelliteStatus_.currentExperimentStep=0;

    uint32_t timeNow = abacus_millis();
    labonchipExperiment_[experimentIndex].startUnixTime=timeNow;
    currentExperimentID=labonchipExperiment_[experimentIndex].experimentID;
    labonchipExperiment_[experimentIndex].stepStatus[0]=RUNNING;
    labonchipExperiment_[experimentIndex].expStartAddress=satelliteMemory_.marieStartFreeAddress;

    // ACTIONS
    int okToGo=0;
    // okToGo+=marieSwitchON();
    // okToGo+=measureDose();
    // okToGo+=measureLTP(); //light temperature and pressure (Kayser board)
    // okToGo+=measureWetIN();
    // okToGo+=measureWetOUT();
    // okToGo+=getTelemetry();
    if (okToGo==0) {
        //exp setup init ok
        labonchipExperiment_[experimentIndex].stepStatus[0]=COMPLETED;

    } else {
        //failed to setup the experiment
        //use binary coding of the errors to know the reason and
        //decide how to handle this situation
        labonchipExperiment_[experimentIndex].stepStatus[0]=ABORTED;
    }
    return okToGo;
}

int setupExperiment(uint8_t experimentIndex,uint8_t id, uint8_t numberofteps,uint8_t *stepactions, uint16_t *stepdurations){
    if(experimentIndex >= NUMBER_OF_EXPERIMENTS)
        return -1;
    if(numberofteps >= MAX_NUMBER_OF_STEPS)
        return -2;
    labonchipExperiment_[experimentIndex].experimentID=id;
    labonchipExperiment_[experimentIndex].numberOfSteps=numberofteps;
    labonchipExperiment_[experimentIndex].startUnixTime=0UL;
    labonchipExperiment_[experimentIndex].endUnixTime=0UL;
    labonchipExperiment_[experimentIndex].elapsedTimeinStep=0UL;
    labonchipExperiment_[experimentIndex].expStartAddress=MEMORY_MARIE_START;
    labonchipExperiment_[experimentIndex].expEndAddress=MEMORY_MARIE_START;
    int i;
    for(i=1; i<numberofteps;i++){
        labonchipExperiment_[experimentIndex].stepStatus[i]=TODO;
        labonchipExperiment_[experimentIndex].stepAction[i]=*stepactions;
        stepactions++;
        labonchipExperiment_[experimentIndex].stepDuration[i]=*stepdurations;
        stepdurations++;
    }
}


int setupStandardExperiment(uint8_t experimentIndex){
    if(experimentIndex >= NUMBER_OF_EXPERIMENTS)
        return -1;
    labonchipExperiment_[experimentIndex].experimentID=experimentIndex;
    labonchipExperiment_[experimentIndex].numberOfSteps=STANDARDSTEPS;
    labonchipExperiment_[experimentIndex].startUnixTime=0UL;
    labonchipExperiment_[experimentIndex].endUnixTime=0UL;
    labonchipExperiment_[experimentIndex].elapsedTimeinStep=0UL;
    labonchipExperiment_[experimentIndex].expStartAddress=MEMORY_MARIE_START;
    labonchipExperiment_[experimentIndex].expEndAddress=MEMORY_MARIE_START;
    int i;
    for(i=1; i<MAX_NUMBER_OF_STEPS;i++){
        labonchipExperiment_[experimentIndex].stepStatus[i]=TODO;
        if (standardActions[i]==PUMPi)
            labonchipExperiment_[experimentIndex].stepAction[i]=experimentIndex+1; // experiment 0 pump 1, ecc.
        else
            labonchipExperiment_[experimentIndex].stepAction[i]=standardActions[i];

        labonchipExperiment_[experimentIndex].stepDuration[i]=standardDurations[i];
    }
    return 0;
}


void setupAllExperiments(){
    int i;
    int res=0;
    for(i=1; i<NUMBER_OF_EXPERIMENTS;i++){
        res+=setupStandardExperiment[i];
    }
}

/*
void finishExperiment(uint8_t experimentIndex){ //alternatively use experimentID

    if(experimentIndex >= NUMBER_OF_EXPERIMENTS)
        return;
    currentExperimentID=labonchipExperiment_[experimentIndex].experimentID;
}
 */
